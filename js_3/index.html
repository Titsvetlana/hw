<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
	<link rel="stylesheet" href="css/style.css">
	<link href="https://fonts.googleapis.com/css?family=Fjalla+One&display=swap" rel="stylesheet">
</head>
<body>
	<div class="header">
		<img src="img/Node_js_logo-512.png" alt="icon">
		<h1>JavaScript</h1>	
	</div>
	<!-- <div class="back-photo"></div> -->
	<div class="container">
		<h3>В чём отличие конкатенации от сложения?</h3>
		<p><strong>Конкатенация</strong> – это процесс соединения вещей друг с другом. В JavaScript конкатенация чаще всего используется для соединения значений переменных друг с другом, или строк со строками (для образования более длинных строк).</p>	
		<pre>
			let welcome = 'Good';
			let time = 'evening'
			alert(welcome + time);
		</pre>
		<p><b>Результат:</b></p> 
		<pre>
			Good evening
		</pre>
		<p><strong>Сложение (+)</strong> - возвращает сумму числовых операндов</p>
		<pre>
			let a = 5;
			let b = 3;
			let с = a + b;
			alert(c)
		</pre>
		<p><b>Результат:</b></p>
		<pre>
			8
		</pre>
		<h3>Опишите три основных правила именования переменных.</h3>
		<ol>
			<li>
			   Правило 1
			    <ul>
				   	<li>
				   		Имена переменных должны отражать смысл хранимого в них значения.
	                    Никакого транслита. Только английский.
				   	</li>
			    </ul>
		   </li>
			<li> 
			   Правило 2
			    <ul>
				   	<li>
				   		Имена не должны совпадать (с точностью до регистра)
	                    или быть очень похожими на ключевые и зарезервированные
						слова, на стандартные объекты и функции, а также
						на имена других переменных.
				   	</li>
			    </ul>
			</li>
			<li>
			   Правило 3 
			    <ul>
				   	<li>
				   		Если имя переменной состоит из нескольких слов,
						то следует придерживаться единых правил их выделения.
						Для имен стандартных функций и объектов
						в Javascript применяется стиль «lowerCamelCase»,
						согласно которому слова пишутся подряд, первое
						слово со строчной (маленькой) буквы, остальные —
						с прописной (большой).
				   	</li>
			    </ul>
			</li>
		</ol>
		<h3>В чем отличие == от ===?</h3>
		<p>
		    <strong>Нестрогие операции сравнения</strong> имеют запись <b>«==»</b>
			(проверка на равенство) или <b>«!=»</b> (проверка на неравенство).
			Тот факт, что операции являются нестрогими, проявляется
			в предварительном преобразовании операндов
			к примитивным типам (насколько это возможно) и последующим
			сравнении. Так, например, проверку пройдут сравнения
			«3=='3'» (число 3 сравнивается со строкой '3'),
			«1==true» (число 1 сравнивается со значением типа
			Boolean), «' '==false» (строка с пробелом сравнивается со
			значением типа Boolean).
			Во всех этих случаях равны между собой значения,
			которые получаются после преобразования операндов
			к числовой форме.
		</p>
		<p>
			<strong>Строгие операции равенство</strong> проверяют при помощи
			выражения <b>«===»</b>, а неравенство — <b>«!==»</b>. В этом случае
			операнды разного типа в любом случае не могут быть
			равными между собой, даже если содержат подобные
			значения.
		</p>
		<h3>Объясните причины использования методов parseInt(), parseFloat(), Number()</h3>
		<i>В двух словах:</i>
		<p>
			<b>parseFloat</b> и <b>parseInt</b> преобразуют в число максимальную соответствующую подстроку, с начала строки, отбросив предварительно пробельные символы.
		</p>
		<p>
			<b>Number</b> - целую строку, так же отбросив предварительно пробельные символы.
		</p>
		<pre>
			//--------------------------//
			console.log(parseFloat('3a'));
			console.log(parseInt('3a'));
			console.log(Number('3a'));
		</pre>
		<p><b>Результат:</b></p>
		<p>
			<img src="img/0arQq8P.png" alt="Result">
		</p>
		<div class="text">
			<p>Для более полного понимания различий можно обратиться к <a href="http://www.ecma-international.org/ecma-262/7.0/">спецификации</a>
			</p>
			<h5><a href="http://www.ecma-international.org/ecma-262/7.0/#sec-number-constructor-number-value">Конструктора Number</a></h5>
			<p>Если данная функция вызывается без <i>new</i>, то</p>
			<ol>
				<li>Если не передали параметров результат будет +0</li>
				<li>Если параметр (value) передан, то будет возвращен результат вызова <i>ToNumber(value)</i></li>
			</ol>
			<p>Где <i>ToNumber(value)</i> - это абстрактная функция, вызываемая, когда необходимо получить числовое значение.</p>
			<h5><a href="http://www.ecma-international.org/ecma-262/7.0/#sec-parseint-string-radix">Функция parseInt</a></h5>
			<p>
				Отличительной особенностью данной функции является возможность передать вторым параметром основание системы счисления, в которой находится число в строке. По умолчанию данный параметр имеет значение: 10.
			</p>
			<p>
				Стоит отметить, что первый аргумент <b>всегда</b> приводится к строке.
			</p>
			<p>Алгоритм работы данной функции весьма прост:</p>
			<ol>
				<li>Отбрасываются пробельные символы с начала строки</li>
				<li>Определяется знак числа</li>
				<li>Выставляет флаг <i>нужно ли отбрасывать префикс</i>, в том случае, если основание равно 16 или не передано.</li>
				<li>
					Если нужно отбрасывать префикс:
					<ul>
						<li>отбрасываются первые два символа, если они равны <i>0x</i> или <i>0X</i></li>
						<li>основанию устанавливается значение 16</li>
					</ul>
				</li>
				<li>Если в строке присутствуют символы не соответствующие основанию, то выбирается подстрока, перед первым таким символом.</li>
				<li>Вычисляется математическое целочисленное значение, соответствующее выбранной подстроке. Символы A-Z и a-z используются для представления значений от 10 до 35 в соответствующих системах счисления.</li>
				<li>полученный результат умножается на знак и возвращается.</li>
			</ol>
			<p>
				Как можно заметить, в отличие от описанной выше функции Number, для разбора используется не вся строка, распознается только префикс для шестнадцатеричных чисел, но при этом добавляется возможность указать основание системы счисления от 2 до 36
			</p>
			<h5><a href="http://www.ecma-international.org/ecma-262/7.0/#sec-parseint-string-radix">Функция parseFloat</a></h5>
			<p>Как и в <i>parseInt</i>, в данной функции всегда идет приведение аргумента к строке.</p>
			<p>Алгоритм схож с работой функции parseInt</p>
			<ol>
				<li>Отбрасываются пробельные символы с начала строки</li>
				<li>Определяется удовлетворяет ли оставшаяся строка или любой из ее префиксов  <a href="http://www.ecma-international.org/ecma-262/7.0/#prod-StrDecimalLiteral">синтаксису StrDecimalLiteral</a>
					<ul>
						<li>если нет, возвращается NaN</li>
						<li>если да - берется максимальный префикс.</li>
					</ul>
				</li>
				<li>Возвращается соответствующее число.</li>
			</ol>
			<p>
				Как можно заметить, по сравнению с <i>Number</i>, для разбора используется часть строки, не допустимы никакие префиксы вроде <i>0x, 0b, 0o</i>. В отличие от parseInt допустима <i>e</i>-нотация
			</p>
		</div>
		<h5>Зачем использовать битовые операции?</h5>
		<p>
			Благодаря реализации в арифметическом логическом устройстве (АЛУ) процессора многие регистровые битовые операции аппаратно доступны в языках низкого уровня. В большинстве процессоров реализованы в качестве инструкции регистровый <b>НЕ</b>; регистровые двухаргументные <b>И</b>, <b>ИЛИ</b>, исключающее <b>ИЛИ</b>, три типа битовых сдвигов, а также циклические битовые сдвиги.
	    </p>
	    <p>
	    	Регистровая операция <b>И</b> используется для:
	    </p>
	    <ul>
	    	<li>проверки бита на 0 или 1</li>
	    	<li>установки 0 в указанный бит (сброса бита)</li>
	    </ul>
	    <p>
	    	Регистровая операция <b>ИЛИ</b> используется для:
	    </p>
	    <ul>
	    	<li>установки 1 в указанный бит</li>
	    </ul>
	    <p>
	    	Регистровая операция исключающее <b>ИЛИ</b> используется для инвертирования битов регистра по маске.
	    </p>
	    <p>
	    	Сдвиг влево/вправо используется для умножения/целочисленного деления на 2 и выделения отдельных битов.
	    </p>
	    <h5>Таблица приоритетов математических операторов</h5>
	    <!-- ЗДЕСЬ ДОЛЖНА БЫТЬ ПРОПИСАНА ТАБЛИЦА, НО НЕТ ВРЕМЕНИ(( -->
	    <div class="table">
	    	<img src="img/Zuig8pA.png" alt="photo">
	    	<img src="img/IuB.png" alt="photo">
	    	<img src="img/Q0Lp8fC.png" alt="photo">
	    	<img src="img/p1PcnEgD.png" alt="photo">
	    	<img src="img/CnOaWayE.png" alt="photo">
	    </div>
	    <h5>Как использовать методы String, Number, Boolean?</h5>
	    <p><i>
	    	Конструкторы String/Number/Boolean предназначены только для внутреннего пользования.
	    </i></p>
	    <p><b>
	    	Строковое преобразование
	    </b></p>
	    <p>
	    	Строковое преобразование происходит, когда требуется представление чего-либо в виде строки. Например, его производит функция <i>alert</i>.
	    </p>
	    <pre>
	    	     var a = true;
		     alert( a ); // "true"
	    </pre>
	    <p><b>
	    	Численное преобразование
	    </b></p>
	    <p>
	    	Численное преобразование происходит в математических функциях и выражениях, а также при сравнении данных различных типов <i>(кроме сравнений ===, !==)</i>.
	    </p>
	    <p>
	    	Для преобразования к числу в явном виде можно вызвать Number(let), либо, что короче, поставить перед выражением унарный плюс "+":
	    </p>
	    <pre>
		    	var a = +"123"; // 123
	                var a = Number("123"); // 123, тот же эффект
	    </pre>
	    <h5>Логическое преобразование</h5>
	    <p>
	    	Преобразование к <i>true/false</i> происходит в логическом контексте, таком как <i>if(value)</i>, и при применении логических операторов.
	    </p>
	    <p>
	    	Все значения, которые интуитивно «пусты», становятся false. Их несколько: 0, пустая строка, null, undefined и NaN.
	    </p>
	    <p>
	    	Остальное, в том числе и любые объекты – true.
	    </p>
	    <p><i>
	    	Полная таблица преобразований:
	    </i></p>
	    <img class="photo" src="img/bool.png" alt="photo">
	</div>
	<footer>
		
	</footer>

</body>
</html>